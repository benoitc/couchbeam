<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Module lhttpc</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module lhttpc</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Main interface to the lightweight http client.

<p><b>Behaviours:</b> <a href="application.html"><tt>application</tt></a>.</p>
<p><b>Authors:</b> Oscar Hellstr√∂m (<a href="mailto:oscar@erlang-consulting.com"><tt>oscar@erlang-consulting.com</tt></a>).</p>

<h2><a name="description">Description</a></h2>Main interface to the lightweight http client.
   See <a href="#request-4"><code>request/4</code></a>, <a href="#request-5"><code>request/5</code></a> and <a href="#request-6"><code>request/6</code></a> functions.
<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#get_body_part-1">get_body_part/1</a></td><td>Reads a body part from an ongoing response when
  <code>{partial_download, PartialDownloadOptions}</code> is used.</td></tr>
<tr><td valign="top"><a href="#get_body_part-2">get_body_part/2</a></td><td>Reads a body part from an ongoing response when
  <code>{partial_download, PartialDownloadOptions}</code> is used.</td></tr>
<tr><td valign="top"><a href="#request-4">request/4</a></td><td>Sends a request without a body.</td></tr>
<tr><td valign="top"><a href="#request-5">request/5</a></td><td>Sends a request with a body.</td></tr>
<tr><td valign="top"><a href="#request-6">request/6</a></td><td>Sends a request with a body.</td></tr>
<tr><td valign="top"><a href="#request-9">request/9</a></td><td>Sends a request with a body.</td></tr>
<tr><td valign="top"><a href="#send_body_part-2">send_body_part/2</a></td><td>Sends a body part to an ongoing request when
  <code>{partial_upload, WindowSize}</code> is used.</td></tr>
<tr><td valign="top"><a href="#send_body_part-3">send_body_part/3</a></td><td>Sends a body part to an ongoing request when
  <code>{partial_upload, WindowSize}</code> is used.</td></tr>
<tr><td valign="top"><a href="#send_trailers-2">send_trailers/2</a></td><td>Sends trailers to an ongoing request when <code>{partial_upload,
  WindowSize}</code> is used and no <code>Content-Length</code> was specified.</td></tr>
<tr><td valign="top"><a href="#send_trailers-3">send_trailers/3</a></td><td>Sends trailers to an ongoing request when
  <code>{partial_upload, WindowSize}</code> is used and no <code>Content-Length</code> was
  specified.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="get_body_part-1">get_body_part/1</a></h3>
<div class="spec">
<p><tt>get_body_part(HTTPClient::pid()) -&gt; Result</tt>
<ul class="definitions"><li><tt>Result = {ok, Bin} | {ok, {http_eob, Trailers}}</tt></li>
<li><tt>Trailers = [{Header, Value}]</tt></li>
<li><tt>Header = string() | binary() | atom()</tt></li>
<li><tt>Value = string() | binary()</tt></li>
</ul></p>
</div><p>Reads a body part from an ongoing response when
  <code>{partial_download, PartialDownloadOptions}</code> is used. The default timeout,
  <code>infinity</code> will be used.
  Would be the same as calling
  <code>get_body_part(HTTPClient, infinity)</code>.</p>

<h3 class="function"><a name="get_body_part-2">get_body_part/2</a></h3>
<div class="spec">
<p><tt>get_body_part(HTTPClient::pid(), Timeout) -&gt; Result</tt>
<ul class="definitions"><li><tt>Timeout = integer() | infinity</tt></li>
<li><tt>Result = {ok, Bin} | {ok, {http_eob, Trailers}}</tt></li>
<li><tt>Trailers = [{Header, Value}]</tt></li>
<li><tt>Header = string() | binary() | atom()</tt></li>
<li><tt>Value = string() | binary()</tt></li>
</ul></p>
</div><p>Reads a body part from an ongoing response when
  <code>{partial_download, PartialDownloadOptions}</code> is used.
  <code>Timeout</code> is the timeout for reading the next body part in milliseconds.
  <code>http_eob</code> marks the end of the body. If there were Trailers in the
  response those are returned with <code>http_eob</code> as well.</p>

<h3 class="function"><a name="request-4">request/4</a></h3>
<div class="spec">
<p><tt>request(URL, Method, Hdrs, Timeout) -&gt; Result</tt>
<ul class="definitions"><li><tt>URL = string()</tt></li>
<li><tt>Method = string() | atom()</tt></li>
<li><tt>Hdrs = [{Header, Value}]</tt></li>
<li><tt>Header = string() | binary() | atom()</tt></li>
<li><tt>Value = string() | binary()</tt></li>
<li><tt>Timeout = integer() | infinity</tt></li>
<li><tt>Result = {ok, {{StatusCode, ReasonPhrase}, Hdrs, ResponseBody}} | {error, Reason}</tt></li>
<li><tt>StatusCode = integer()</tt></li>
<li><tt>ReasonPhrase = string()</tt></li>
<li><tt>ResponseBody = binary()</tt></li>
<li><tt>Reason = connection_closed | connect_timeout | timeout</tt></li>
</ul></p>
</div><p>Sends a request without a body.
  Would be the same as calling <code>request(URL, Method, Hdrs, [], Timeout)</code>,
  that is <a href="#request-5"><code>request/5</code></a> with an empty body (<code>Body</code> could also be <code>&lt;&lt;&gt;&gt;</code>).</p>

<h3 class="function"><a name="request-5">request/5</a></h3>
<div class="spec">
<p><tt>request(URL, Method, Hdrs, Body::RequestBody, Timeout) -&gt; Result</tt>
<ul class="definitions"><li><tt>URL = string()</tt></li>
<li><tt>Method = string() | atom()</tt></li>
<li><tt>Hdrs = [{Header, Value}]</tt></li>
<li><tt>Header = string() | binary() | atom()</tt></li>
<li><tt>Value = string() | binary()</tt></li>
<li><tt>RequestBody = <a href="#type-iolist">iolist()</a></tt></li>
<li><tt>Timeout = integer() | infinity</tt></li>
<li><tt>Result = {ok, {{StatusCode, ReasonPhrase}, Hdrs, ResponseBody}} | {error, Reason}</tt></li>
<li><tt>StatusCode = integer()</tt></li>
<li><tt>ReasonPhrase = string()</tt></li>
<li><tt>ResponseBody = binary()</tt></li>
<li><tt>Reason = connection_closed | connect_timeout | timeout</tt></li>
</ul></p>
</div><p>Sends a request with a body.
  Would be the same as calling
  <code>request(URL, Method, Hdrs, Body, Timeout, [])</code>, that is <a href="#request-6"><code>request/6</code></a>
  with no options.</p>

<h3 class="function"><a name="request-6">request/6</a></h3>
<div class="spec">
<p><tt>request(URL, Method, Hdrs, Body::RequestBody, Timeout, Options) -&gt; Result</tt>
<ul class="definitions"><li><tt>URL = string()</tt></li>
<li><tt>Method = string() | atom()</tt></li>
<li><tt>Hdrs = [{Header, Value}]</tt></li>
<li><tt>Header = string() | binary() | atom()</tt></li>
<li><tt>Value = string() | binary()</tt></li>
<li><tt>RequestBody = <a href="#type-iolist">iolist()</a></tt></li>
<li><tt>Timeout = integer() | infinity</tt></li>
<li><tt>Options = [Option]</tt></li>
<li><tt>Option = {connect_timeout, Milliseconds | infinity} | {send_retry, integer()} | {partial_upload, WindowSize}</tt></li>
<li><tt>Milliseconds = integer()</tt></li>
<li><tt>WindowSize = integer() | infinity</tt></li>
<li><tt>Result = {ok, {{StatusCode, ReasonPhrase}, Hdrs, ResponseBody}} | {ok, UploadState} | {error, Reason}</tt></li>
<li><tt>StatusCode = integer()</tt></li>
<li><tt>ReasonPhrase = string()</tt></li>
<li><tt>ResponseBody = binary()</tt></li>
<li><tt>Reason = connection_closed | connect_timeout | timeout</tt></li>
</ul></p>
</div><p>Sends a request with a body.
  Would be the same as calling <pre>
  {Host, Port, Path, Ssl} = lhttpc_lib:parse_url(URL),
  request(Host, Port, Path, Ssl, Method, Hdrs, Body, Timeout, Options).
  </pre>
 
  <code>URL</code> is expected to be a valid URL:
  <code>scheme://host[:port][/path]</code>.</p>

<h3 class="function"><a name="request-9">request/9</a></h3>
<div class="spec">
<p><tt>request(Host, Port, Ssl, Path, Method, Hdrs, Body::RequestBody, Timeout, Options) -&gt; Result</tt>
<ul class="definitions"><li><tt>Host = string()</tt></li>
<li><tt>Port = integer()</tt></li>
<li><tt>Ssl = <a href="#type-boolean">boolean()</a></tt></li>
<li><tt>Path = string()</tt></li>
<li><tt>Method = string() | atom()</tt></li>
<li><tt>Hdrs = [{Header, Value}]</tt></li>
<li><tt>Header = string() | binary() | atom()</tt></li>
<li><tt>Value = string() | binary()</tt></li>
<li><tt>RequestBody = <a href="#type-iolist">iolist()</a></tt></li>
<li><tt>Timeout = integer() | infinity</tt></li>
<li><tt>Options = [Option]</tt></li>
<li><tt>Option = {connect_timeout, Milliseconds | infinity} | {send_retry, integer()} | {partial_upload, WindowSize} | {partial_download, PartialDowloadOptions}</tt></li>
<li><tt>Milliseconds = integer()</tt></li>
<li><tt>WindowSize = integer()</tt></li>
<li><tt>PartialDownloadOptions = [PartialDownloadOption]</tt></li>
<li><tt>PartialDowloadOption = {window_size, WindowSize} | {part_size, PartSize}</tt></li>
<li><tt>PartSize = integer()</tt></li>
<li><tt>Result = {ok, {{StatusCode, ReasonPhrase}, Hdrs, ResponseBody}} | {error, Reason}</tt></li>
<li><tt>StatusCode = integer()</tt></li>
<li><tt>ReasonPhrase = string()</tt></li>
<li><tt>ResponseBody = binary() | pid() | undefined</tt></li>
<li><tt>Reason = connection_closed | connect_timeout | timeout</tt></li>
</ul></p>
</div><p><p>Sends a request with a body.</p>
 
  <p>Instead of building and parsing URLs the target server is specified with
  a host, port, weither SSL should be used or not and a path on the server.
  For instance, if you want to request http://example.com/foobar you would
  use the following:<br>
  <code>Host</code> = <code>"example.com"</code><br>
  <code>Port</code> = <code>80</code><br>
  <code>Ssl</code> = <code>false</code><br>
  <code>Path</code> = <code>"/foobar"</code><br>
  <code>Path</code> must begin with a forward slash <code>/</code>.</p>
 
  <p><code>Method</code> is either a string, stating the HTTP method exactly as in the
  protocol, i.e: <code>"POST"</code> or <code>"GET"</code>. It could also be an atom, which is
  then made in to uppercase, if it isn't already.
  <code>Hdrs</code> is a list of headers to send. Mandatory headers such as
  <code>Host</code>, <code>Content-Length</code> or <code>Transfer-Encoding</code> (for some requests)
  are added.
  <code>Body</code> is the entity to send in the request. Please don't include entity
  bodies where there shouldn't be any (such as for <code>GET</code>).
  <code>Timeout</code> is the timeout for the request in milliseconds.
  <code>Options</code> is a list of options.</p>
 
  <p>Options:</p>
 
  <p><code>{connect_timeout, Milliseconds}</code> specifies how many milliseconds the  
client can spend trying to establish a connection to the server. This  
doesn't affect the overall request timeout. However, if it's longer than  
the overall timeout it will be ignored. Also note that the TCP layer my  
choose to give up earlier than the connect timeout, in which case the  
client will also give up. The default value is infinity, which means that  
it will either give up when the TCP stack gives up, or when the overall  
request timeout is reached.</p>
 
  <p><code>{send_retry, N}</code> specifies how many times the client should retry
  sending a request if the connection is closed after the data has been
  sent. The default value is <code>1</code>. If <code>{partial_upload, WindowSize}</code>  
(see below) is specified, the client cannot retry after the first part  
of the body has been sent since it doesn't keep the whole entitity body  
in memory.</p>
 
  <p><code>{partial_upload, WindowSize}</code> means that the body will be supplied in
  parts to the client by the calling process. The <code>WindowSize</code> specifies how
  many parts can be sent to the process controlling the socket before waiting
  for an acknowledgement. This is to create a kind of internal flow control
  if the network is slow and the process is blocked by the TCP stack. Flow
  control is disabled if <code>WindowSize</code> is <code>infinity</code>. If <code>WindowSize</code> is an
  integer, it must be &gt;= 0.  If partial upload is specified and no
  <code>Content-Length</code> is specified in <code>Hdrs</code> the client will use chunked
  transfer encoding to send the entity body. If a content length is
  specified, this must be the total size of the entity body.
  The call to <a href="#request-6"><code>request/6</code></a> will return <code>{ok, UploadState}</code>. The
  <code>UploadState</code> is supposed to be used as the first argument to the <a href="#send_body_part-2"><code>send_body_part/2</code></a> or <a href="#send_body_part-3"><code>send_body_part/3</code></a> functions to send body parts.  
Partial upload is intended to avoid keeping large request bodies in  
memory but can also be used when the complete size of the body isn't known  
when the request is started.</p>
 
  <code>{partial_download, PartialDownloadOptions}</code> means that the response body
  will be supplied in parts by the client to the calling process. The partial
  download option <code>{window_size, WindowSize}</code> specifies how many part will be
  sent to the calling process before waiting for an acknowledgement. This is
  to create a kind of internal flow control if the calling process is slow to
  process the body part and the network is considerably faster. Flow control
  is disabled if <code>WindowSize</code> is <code>infinity</code>. If <code>WindowSize</code> is an integer it
  must be &gt;=0. The partial download option <code>{part_size, PartSize}</code> specifies
  the size the body parts should come in. Note however that if the body size
  is not determinable (e.g entity body is termintated by closing the socket)
  it will be delivered in pieces as it is read from the wire. There is no
  caching of the body parts until the amount reaches body size. If the body
  size is bounded (e.g <code>Content-Length</code> specified or
  <code>Transfer-Encoding: chunked</code> specified) it will be delivered in <code>PartSize</code>
  pieces. Note however that the last piece might be smaller than <code>PartSize</code>.
  Size bounded entity bodies are handled the same way as unbounded ones if
  <code>PartSize</code> is <code>infinity</code>. If <code>PartSize</code> is integer it must be &gt;= 0.
  If <code>{partial_download, PartialDownloadOptions}</code> is specified the
  <code>ResponseBody</code> is going to be a <code>pid()</code> unless the response has no body
  (for example in case of <code>HEAD</code> requests). In that case it is going to be
  <code>undefined</code>.</p>

<h3 class="function"><a name="send_body_part-2">send_body_part/2</a></h3>
<div class="spec">
<p><tt>send_body_part(UploadState, BodyPart) -&gt; Result</tt>
<ul class="definitions"><li><tt>BodyPart = <a href="#type-iolist">iolist()</a> | binary()</tt></li>
<li><tt>Timeout = integer() | infinity</tt></li>
<li><tt>Result = {error, Reason} | UploadState</tt></li>
<li><tt>Reason = connection_closed | connect_timeout | timeout</tt></li>
</ul></p>
</div><p>Sends a body part to an ongoing request when
  <code>{partial_upload, WindowSize}</code> is used. The default timeout, <code>infinity</code>
  will be used. Notice that if <code>WindowSize</code> is infinity, this call will never
  block.
  Would be the same as calling
  <code>send_body_part(UploadState, BodyPart, infinity)</code>.</p>

<h3 class="function"><a name="send_body_part-3">send_body_part/3</a></h3>
<div class="spec">
<p><tt>send_body_part(UploadState, BodyPart, Timeout) -&gt; Result</tt>
<ul class="definitions"><li><tt>BodyPart = <a href="#type-iolist">iolist()</a> | binary()</tt></li>
<li><tt>Timeout = integer() | infinity</tt></li>
<li><tt>Result = {error, Reason} | UploadState</tt></li>
<li><tt>Reason = connection_closed | connect_timeout | timeout</tt></li>
</ul></p>
</div><p><p>Sends a body part to an ongoing request when
  <code>{partial_upload, WindowSize}</code> is used.
  <code>Timeout</code> is the timeout for the request in milliseconds.</p>
 
  <p>If the window size reaches 0 the call will block for at maximum Timeout
  milliseconds. If there is no acknowledgement received during that time the
  the request is cancelled and <code>{error, timeout}</code> is returned.</p>
 
  <p>As long as the window size is larger than 0 the function will return  
immediately after sending the body part to the request handling process.</p>
 
  The <code>BodyPart</code> <code>http_eob</code> signals an end of the entity body, the request
  is considered sent and the response will be read from the socket. If
  there is no response within <code>Timeout</code> milliseconds, the request is
  canceled and <code>{error, timeout}</code> is returned.</p>

<h3 class="function"><a name="send_trailers-2">send_trailers/2</a></h3>
<div class="spec">
<p><tt>send_trailers(UploadState, Trailers) -&gt; Result</tt>
<ul class="definitions"><li><tt>Header = string() | binary() | atom()</tt></li>
<li><tt>Value = string() | binary()</tt></li>
<li><tt>Result = {ok, {{StatusCode, ReasonPhrase}, Hdrs, ResponseBody}} | {error, Reason}</tt></li>
<li><tt>Reason = connection_closed | connect_timeout | timeout</tt></li>
</ul></p>
</div><p>Sends trailers to an ongoing request when <code>{partial_upload,
  WindowSize}</code> is used and no <code>Content-Length</code> was specified. The default
  timout <code>infinity</code> will be used. Note that after this the request is
  considered complete and the response will be read from the socket.
  Would be the same as calling
  <code>send_trailers(UploadState, BodyPart, infinity)</code>.</p>

<h3 class="function"><a name="send_trailers-3">send_trailers/3</a></h3>
<div class="spec">
<p><tt>send_trailers(UploadState, Trailers, Timeout) -&gt; Result</tt>
<ul class="definitions"><li><tt>Trailers = [{Header, Value}]</tt></li>
<li><tt>Header = string() | binary() | atom()</tt></li>
<li><tt>Value = string() | binary()</tt></li>
<li><tt>Timeout = integer() | infinity</tt></li>
<li><tt>Result = {ok, {{StatusCode, ReasonPhrase}, Hdrs, ResponseBody}} | {error, Reason}</tt></li>
<li><tt>Reason = connection_closed | connect_timeout | timeout</tt></li>
</ul></p>
</div><p><p>Sends trailers to an ongoing request when
  <code>{partial_upload, WindowSize}</code> is used and no <code>Content-Length</code> was
  specified.
  <code>Timeout</code> is the timeout for sending the trailers and reading the  
response in milliseconds.</p>
 
  Sending trailers also signals the end of the entity body, which means
  that no more body parts, or trailers can be sent and the response to the
  request will be read from the socket. If no response is received within
  <code>Timeout</code> milliseconds the request is canceled and <code>{error, timeout}</code> is
  returned.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Oct 14 2009, 11:39:56.</i></p>
</body>
</html>
